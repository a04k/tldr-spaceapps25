import { promises as fs } from 'fs';
import path from 'path';

// Parse frontmatter from scientific MDX content, handling special cases
function parseScientificFrontmatter(content: string): { frontmatter: any; content: string } {
  // Look for standard frontmatter (between ---)
  const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/m;
  const match = content.match(frontmatterRegex);

  if (!match) {
    return { frontmatter: {}, content };
  }

  const [, frontmatterStr, contentStr] = match;
  const frontmatter = parseYaml(frontmatterStr);
  
  // Fix common scientific notation issues in the content
  let safeContent = contentStr;
  
  // Replace common scientific notations that might be misinterpreted as HTML
  // p < 0.05 patterns
  safeContent = safeContent.replace(/\b(p|P)\s*<\s*([0-9.]+)\b/g, '$1 &lt; $2');
  // Other common patterns
  safeContent = safeContent.replace(/\b([a-zA-Z])\s*<\s*([a-zA-Z0-9.])\b/g, '$1 &lt; $2');
  
  return { frontmatter, content: safeContent };
}

// Simple YAML parser for frontmatter (handles basic cases)
function parseYaml(yamlStr: string): any {
  const result: any = {};
  
  // Handle the specific example case with complex characters
  const lines = yamlStr.split('\n');
  for (const line of lines) {
    if (line.trim() && line.includes(':')) {
      // Find the first colon that's not within quotes
      let colonIndex = -1;
      let inQuotes = false;
      let quoteChar = '';
      
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if ((char === '"' || char === "'") && (i === 0 || line[i-1] !== '\\')) {
          if (!inQuotes) {
            inQuotes = true;
            quoteChar = char;
          } else if (char === quoteChar) {
            inQuotes = false;
            quoteChar = '';
          }
        } else if (char === ':' && !inQuotes) {
          colonIndex = i;
          break;
        }
      }
      
      if (colonIndex !== -1) {
        const key = line.substring(0, colonIndex).trim();
        let value = line.substring(colonIndex + 1).trim();
        
        // Remove outer quotes if they exist
        if ((value.startsWith('"') && value.endsWith('"')) || 
            (value.startsWith("'") && value.endsWith("'"))) {
          value = value.substring(1, value.length - 1);
        }
        
        // Handle array syntax (semicolon-separated values)
        if (value.includes(';')) {
          result[key] = value.split(';').map(item => item.trim());
        } else {
          result[key] = value;
        }
      }
    }
  }
  
  return result;
}

// Get all scientific papers from the data/papers directory
export async function getAllScientificPapers() {
  const directoryPath = path.join(process.cwd(), 'data', 'papers');
  let files: string[] = [];
  
  try {
    files = await fs.readdir(directoryPath);
  } catch (error) {
    console.error('Error reading papers directory:', error);
    return [];
  }
  
  const mdxFiles = files.filter(file => path.extname(file) === '.mdx');
  
  const papers: any[] = [];
  
  for (const file of mdxFiles) {
    const filePath = path.join(directoryPath, file);
    const fileContent = await fs.readFile(filePath, 'utf8');
    
    const { frontmatter, content } = parseScientificFrontmatter(fileContent);
    
    // Generate an ID from the filename (without extension)
    const id = path.parse(file).name;
    
    papers.push({
      id,
      title: frontmatter.title || id,
      authors: Array.isArray(frontmatter.authors) 
        ? frontmatter.authors 
        : frontmatter.authors?.split(';').map((a: string) => a.trim()) || [],
      year: frontmatter.year || new Date().getFullYear(),
      citations: frontmatter.citations || 0,
      abstract: frontmatter.description || frontmatter.abstract,
      keywords: Array.isArray(frontmatter.keywords) 
        ? frontmatter.keywords 
        : frontmatter.keywords?.split(';').map((k: string) => k.trim()) || [],
      journal: frontmatter.journal,
      doi: frontmatter.doi,
      url: frontmatter.url,
      content: content, // Use abstract as content
      _id: file, // Keep original filename
      slug: id, // ID without extension
      parsedAuthors: Array.isArray(frontmatter.authors) 
        ? frontmatter.authors 
        : frontmatter.authors?.split(';').map((a: string) => a.trim()) || [],
      parsedKeywords: Array.isArray(frontmatter.keywords) 
        ? frontmatter.keywords 
        : frontmatter.keywords?.split(';').map((k: string) => k.trim()) || [],
      wordCount: content.split(/\s+/).length,
      readingTime: Math.ceil(content.split(/\s+/).length / 200),
      body: {
        raw: content,
        code: '' // Will be generated by MDX processing on client side if needed
      },
      filePath: filePath,
      sourceFilePath: filePath,
      titleWithoutExt: id
    });
  }
  
  return papers;
}

// Get a specific scientific paper by ID
export async function getScientificPaperById(id: string) {
  const directoryPath = path.join(process.cwd(), 'data', 'papers');
  const fileName = id + '.mdx';
  const filePath = path.join(directoryPath, fileName);
  
  try {
    const fileContent = await fs.readFile(filePath, 'utf8');
    const { frontmatter, content } = parseScientificFrontmatter(fileContent);
    
    return {
      id,
      title: frontmatter.title || id,
      authors: Array.isArray(frontmatter.authors) 
        ? frontmatter.authors 
        : frontmatter.authors?.split(';').map((a: string) => a.trim()) || [],
      year: frontmatter.year || new Date().getFullYear(),
      citations: frontmatter.citations || 0,
      abstract: frontmatter.description || frontmatter.abstract,
      keywords: Array.isArray(frontmatter.keywords) 
        ? frontmatter.keywords 
        : frontmatter.keywords?.split(';').map((k: string) => k.trim()) || [],
      journal: frontmatter.journal,
      doi: frontmatter.doi,
      url: frontmatter.url,
      content: content,
      _id: fileName,
      slug: id,
      parsedAuthors: Array.isArray(frontmatter.authors) 
        ? frontmatter.authors 
        : frontmatter.authors?.split(';').map((a: string) => a.trim()) || [],
      parsedKeywords: Array.isArray(frontmatter.keywords) 
        ? frontmatter.keywords 
        : frontmatter.keywords?.split(';').map((k: string) => k.trim()) || [],
      wordCount: content.split(/\s+/).length,
      readingTime: Math.ceil(content.split(/\s+/).length / 200),
      body: {
        raw: content,
        code: ''
      },
      filePath: filePath,
      sourceFilePath: filePath,
      titleWithoutExt: id
    };
  } catch (error) {
    console.error(`Error reading paper ${id}:`, error);
    return null;
  }
}

// Search scientific papers based on query
export async function searchScientificPapers(query: string) {
  if (!query.trim()) return [];
  
  const papers = await getAllScientificPapers();
  const lowerQuery = query.toLowerCase();
  
  return papers.filter(paper => 
    String(paper.title || '').toLowerCase().includes(lowerQuery) ||
    paper.parsedAuthors?.some((author: string) => String(author || '').toLowerCase().includes(lowerQuery)) ||
    String(paper.abstract || '').toLowerCase().includes(lowerQuery) ||
    String(paper.content || '').toLowerCase().includes(lowerQuery) ||
    (paper.parsedKeywords && paper.parsedKeywords?.some((keyword: string) => String(keyword || '').toLowerCase().includes(lowerQuery)))
  );
}